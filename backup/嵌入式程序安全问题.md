### 一、千奇百怪的BUG

#### 1.数组越界

```c
void buf_overflow(int n, char val)
{
    volatile char buf[5];//内存分配的时遵循地址对齐原则，分配8个字节
    volatile int a = 0x55;
    buf[0] = 0x5a;
    a++;
    buf[n] = val;
    printf("buf[0] =  0x%x a = 0x%x\n", buf[0], a);//buf[0] =  0x5a a = 0x56 || 段错误 (核心已转储)
}//函数返回地址也在栈空间
```

* 变量被修改（不一定，分配内存存在内存对齐）
* 返回地址被修改，可能会执行到别的函数（返回值刚好是另一个函数的地址）  
* 远在天边的函数变量被修改

#### 2.未赋值的函数指针

```c
int (*f) (int a, int b)//定义函数指针 f = 0x00000000
```

#### 3.加不加打印效果不一样

* 一个直接用变量值，一个去栈里面拿值用

#### 4.加上for循环就没问题了

* 主要是因为定义了一个新的变量，在栈区

### 二、栈溢出

* 栈溢出是最常见、危害最大的软件漏洞之一；要理解栈溢出攻击的原理，需要对计算机程序中函数的调用和返回过程的底层细节有清晰的理解，尤其时这样的一个问题：计算机是如何保存某个函数调用的吓一跳指令地址，实现函数执行完成之后跳回函数调用处，继续往下执行的？

#### 1.什么是栈溢出

* 在这里存在漏洞的关键在于，函数返回后，继续执行的下一条指令地址是从内存的某一个位置读出来的，如果内存中的这个值在函数返回之前被修改，那么程序的执行流程就会被修改。
* 而造成这个值被修改的最常见的原因就是对函数内某个局部数组的操作，发生了越界，如果越界范围超过了当前函数栈帧的尾部，就会吧之前爆粗不在栈中的RBP（基址指针）和RIP（指令指针）值给修改掉。
* 在大多数情况下，栈溢出会导致层序在函数返回后崩溃，但是，如果精心构造栈溢出数据，把保存在RIP值的内存位置修改成某个特定的值，就可以实现控制代码执行过程，让他执行自己定于的一段代码的效果
* 例如，如下的一段代码就是典型的栈溢出漏洞的程序，她把外部的输入复制到一个局部缓冲区，燃火执行一些自己的逻辑，但是并没有严格的检查数据输入的长度，就使得外部精心构造的输入数据可以控制check_param函数返回之后的执行流程

```c
void check_param(char *param)
{
    char buffer[128];
    strcpy(buffer,param);
    ......
}

int main()
{
    check_param(argv[1]);
    ......
}
```

#### 2.如何防止栈溢出

* 从上面的分析可以看出，只要对栈内数组操作的边界执行严格仔细的检查，杜绝任何数组越界访问的行为，就可以阻止栈溢出攻击
* 在上面的程序中，只需要把strcpy改成具有边界检查功能的strncpy，就可以堵住这个漏洞

```c
void check_param(char *param)
{
    char buffer[128];
    strncpy(buffer, param, sizeof(buffer));
    ......
}
```

### 三、堆溢出

#### 1.什么是堆溢出

* 与栈溢出相似，分配在堆上的内存也会发生溢出，溢出之后也会修改掉一些本不该被修改的数据。只是利用堆溢出控制程序执行流程的过程更加复杂

* 这是最常见的对内存溢出的攻击方式，要理解这种攻击方式的实现原理，需要先理解一下glibc的堆内存管理策略。当用户通过glibc的动态内存分配函数申请一块内存时，库函数不会内茨都去向操作系统请求同样大小的内存，而实会一次性申请一块相对较大的内存，然后把这块内存做些分割，并把合适大小的一块返回给应用程序。当应用程序再次申请时，库函数会先在已经从操作系统拿到的那些内存块中查找是否已经有能满足要求的内存块，如果有就直接返回。

* 应用程序持续不断的申请和释放内存块，库函数还要尽量避免内存碎片的产生，所以，当用户释放一块内存时，他会检查该块内存的前后两块相邻内存的空闲状态，如果他们也是空闲的，就把这几块连续的空闲内存合并。而这个合并操作，就是删除双向链表中的某个节点。如下

  ```c
  void unlink(malloc_chunk *P, malloc_chunk *BK, malloc_chunk *FD)
  {
      FD = P->fd;
      BK = P->bk;
      FD->bk = bk;//内存写操作
      BK->fd = FD;//内存写操作
  }
  ```

* 上面是一个典型的从双向链表中删除某个节点的操作，其中P时要删除的中间节点，而BK和FD分别是P节点的后一个和前一个结点。他有两个内存写操作，而写内存的地址和写入的内容，都来至于相邻内存中的数据。所以，如果程序中存在堆溢出缺陷，攻击则就可以用设计的数据，去操作malloc_chunk结构中的指针值，使得在执行这个内存写操作的时候，去修改你希望修改的数据。
* 比如，可以把内存地址修改成计算得到的GOT飙中某个库函数的地址，而写入内存的值修改成某段shellcode的入口地址。这样，当程序在后面调用到这函数之后，就会实际去执行自己提前准备的shellcode，原理很容易理解，但是操作起来就需要高超的技巧和精确的计算。而且，并不是任意大小的堆内存溢出都能够内利用来实现程序的1流程控制，因为在glibc的内存管理策略中，为了加快小块内存的分配和释放效率，大小不超过64字节的内存块使用fastbin组织管理的，而不会被链表在双向链表中，他们在释放之后不会只想前后内存块的合并操作

#### 2.如何防止堆溢出

* 与栈溢出相似，封堵堆溢出的关键在于层序中用到的所有内存操作，都要严格检查操作边界，比如，任何用到memcpy、strcpy等函数的地方，都要对输入数据执行严格的长度检查，保证其不会操作曹处预定义的缓冲区的内存。对于复杂计算得到的数组下标，也要小心处理，确保落在有效范围内。

### 三、格式化字符串漏洞

#### 1.什么是格式化字符串漏洞

* 格式化字符串漏洞产生的原因在于程序没有对外部输入的内容执行严格的检查和过滤，当这样的数据作为参数传递给某些格式化操作函数，如printf、fprintf等时，就可能被恶意利用，比如，一个简单的存在格式化字符串漏洞程序如下

  ```CQL
  int main()
  {
  	char buffer[1024];
  	strcpy(buffer, argv[1], sizeof(buffer) - 1);
  	prinf(buffer);
  	return 0;
  }
  ```

* 在这个程序中，虽然使用了带有边界检查功能的strncpy函数执行内存的复制，没有溢出漏洞，但是在使用printf函数输出buffer内容时，并没有对外部输入内容执行任何形式的验证和检查。这样，外部输入的数据中如果带了%s或者%x等格式符时，就会意外的输出一些本不该显示出来的内容。甚至，还可以精心构造带有%n格式化的输入，实现向某个内存地址写入数据，让程序返回时，去执行某段自定义的shellcode，达到目的。

#### 2.如何防止格式化字符串漏洞

* 要防范这种漏洞，只要对输入数据执行严格的检查就可以了。
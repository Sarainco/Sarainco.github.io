# 应用编程与网络编程

## 第一章 Linux中的文件IO

### 一、文件操作的主要API

#### 1.文件操作的主要API

* API是一些由Linux系统提供支持的函数，有应用程序来使用。
* 应用程序通过调用API来调用操作系统的API。
* 学习一个操作系统，就是学习使用这个操作系统的API。

#### 2.Linux常用的文件API

```c
open | close | write | read | lseek
```

#### 3.文件操作的一般步骤

* open打开一个文件，得到一个文件描述符，然后对文件进行读写操作（或其他操作），最后close关闭文件即可。
* 文件平时是存放在文件系统中的块设备，我们把这种文件叫做静态文件。当我们去open打开一个文件时，Linux的内核操作包括：在进程中建立一个打开文件的数据结构，记录下打开的这个文件，然后申请一块内存，将静态文件的内容从块设备读取到内存中的特定地址管理存放，成为动态文件。
* 文件打开后，针对这份文件的读写操作，都是针对这份动态文件的。当我们close关闭动态文件时，内核将内存中的动态文件更新到块设备中静态文件。
* 常见现象：打开一个大文件时比较慢；写了一半的文件如果没保存直接关机，重启后文件内容丢失。
* 为什么要这么设及？因为块设备本身有读写限制，对块设备的操作非常不灵活。而内存可以按字节为单位操作，而且可以随时操作，很灵活。

#### 4.重要概念：文件描述符

* 文件描述符实际上是一个数字，在进程中表示一个特定的含义，当我们open打开一个文件时，操作系统在内存中构建了一些数据结构来表示这个动态文件，然后返回给应用程序一个数字作为文件描述符，即该进程中该文件的标识。
* 注意文件描述符的作用域就是该进程，出了当前进程这个文件描述符就没有意义了。

### 二、一个简单的文件读写实例

#### 1. 文件的打开与文件的关闭

* Linux中的文件描述符fd的合法范围是0或则一个正整数，不可能是一个负数。
* open返回的fd必须用记录好，对文件的所有操作都离不开fd。

#### 2. 实时查询man手册

* man 1 xxx查询Linux shell命令、man 2 xxx查询API、man 3 xxx 查询库函数

#### 3. 读取文件内容

* ssize_t read(int fd, void *buf, size_t count);ssize_t是内核重定义的的一个类型，其实就是int，返回值表示成功读取的字节数；fd表示文件描述符，buf是应用程序自己提供的一段缓冲区，用来存储读出的内容；count是要读取的字节数。

#### 4. 向文件中写入内容

* ssize_t write(int fd, const void *buf, size_t count)

### 三、open函数的flags（第二个参数）详解

#### 1. 读写权限

* ```c
  O_RDONLY | O_WRONLY | O_RDWR
  ```

#### 2. 打开存在并有内容的文件时，对原内容的处理：O_APPEND、O_TRUNC

* O_APPEND：原有内容保留，将新内容添加在后面
* O_TRUNC：原内容全部删除，新内容重头开始添加
* 如果O_APPEND | O_TRUNC 则为O_TRUNC的效果。
* 不使用这两个的时候，若不读不写或则读，则原内容保持不变，若写，则原内容被逐个替代。

#### 3. 退出程序：exit(库函数)、_exit(API)、\_Exit(API)

* 当我们的程序在前面的某个操作失败导致后面的操作都无法进行的时候，应该及时退出整个程序。
* 如何退出程序：在main中用return，一般正常return 0 ，异常return -1。正式终止进程应该使用exit\\_exit\\\_Exit三者之一。

#### 4.打开不存在的文件时：O_CREAT、O_EXCL

* 当我们打开一个不存在的文件时，一般会报错，若此时加上O_CREAT，则无论该文件存在与否，都会直接创建一个新文件。
* 但O_CREAT会带来一个新问题，当我们打错文件名字的时候，会导致别的文件被创建，即原内容被清空。
* 若此时加上O_EXCL，则对于文件已经存在的情况下，会报错而不是重新创建。
* 当使用O_CREAT去创建一个新文件时，可以使用open函数的第三个参数mode来指定该文件的权限。

#### 5. 以非阻塞的方式打开设备文件：O_NONBLOCK

* 阻塞和非阻塞：如果一个函数是阻塞式的，则调用这个函数时可能因为函数执行条件未具备而被卡住一直等待。如果他是非阻塞的，那么调用函数后会立即返回，但函数有没有完成任务不确定。
* 阻塞式的结果有保障但时间没有保障，非阻塞式的时间有保障但结果没有保障。
* 操作系统提供的API和由API封装而成的库函数，有很多本身被设计为阻塞式或则非阻塞式的，使用我们调用这些函数时要心里有数。
* 该flag只能用于设备文件，不能用于普通文件。

#### 6.写阻塞等待：O_SYNC

* write阻塞等待底层完成写入才返回到应用层。
* 无O_SYNC时write只是将内容写入底层缓冲区则返回，然后底层再合适的时候再将内容一次性同步到硬盘中。这种设计是为了提高硬件操作的效率以及硬件的寿命，但有时我们需要不到等待立即写入，则可用O_SYNC。

### 四、文件读写的一些细节

#### 1.errno和perror

* errno就是error number，即错误码
* errno实质上就是一个数字，每个数字对应一种错误。
* perror就是print error 即打印错误。

#### 2. read和write的count

* count表示我们想要读或则写的字节数，返回值表示实际完成的字节数。
* count在和阻塞、非阻塞结合起来，就会更加复杂，如果一个函数是阻塞式的，我们想要读取30个字节，而实际只完成了20个字节，就会导致阻塞。
* 有时候我们想要写正是程序时，要读出或则写入的往往是一个很大的文件（eg:2M）我们不可能把count设置成2\*1024\*1024，而是把count设置成为一个合适的数字（eg:2048）然后通过多次读写来完成任务。

#### 3.文件IO和标准IO的效率

* 文件IO就是指open、read、write、close等API函数构成的一套用来读写文件的体系，他能完成读写，但效率不高。
* 应用层c语言库函数提供了一套用来读写文件的函数列表，叫标准IO，标准IO由一系列C库函数（fopen、fread、fwrite、fclose）构成，这些标准IO都是由文件IO封装而来，其实就是再应用层加了一个缓冲机制，这样我们通过fwrite写入的内容不是直接进入内核中的buf，而是进入了应用层标准IO库自己维护的buf中，然后标准IO库更具操作系统单次write的最佳count来选择合适的时候将内容写入内核的buf中。

### 五、Linux如何管理文件

#### 1. 硬盘中的静态文件和inode（i节点）

* 硬盘（块设备）-> block -> 扇区 -> 字节
* 一块硬盘可以分为两个区域：硬盘内容管理表、真正的存储内容的区域。操作系统访问硬盘时先去读取硬盘的管理表，从中找到对应文件的扇区信息，然后再通过这个信息去查询真正存储内容的区域。
* 管理表中每个文件对应一个inode，每个inode有一个数字编号，对应一个结构体，结构体中记录了该文件的各种信息。
* 格式化u盘，一般有两种方法，一种是删除内容管理表，一种是删除所有内容。

#### 2.内存中的动态文件和vnode(v节点)

* 一个程序的运行就是一个进程，进程中打开的文件就是该进程。每个进程都有一个进程信息表记录了这个进程的所有信息，表中有一个指针会指向一个文件管理表，文件管理表记录了这个进程的所有信息，通过文件信息中的文件描述符fd就可以找到特定文件的vnode。
* 一个vnode记录了一个被打开的文件的各种信息。

#### 3. 文件与流的概念

* 文件操作中，一个文件中很多个字符的数据被挨个读出或写入时，就构成了一个字符流。
* 流的概念是动态的。
* 编程中提到流这个概念，一般都是IO相关的，所以经常叫IO流，文件操作时就构成了一个IO流。

### 六、lseek函数详解

#### 1.lseek函数介绍

* 文件指针：动态文件在内存中是文件流的形式，文件流很长，有很多个字节，文件指针指出了当前正在操作的位置，就如GUI下的光标一样。
* lseek函数：文件指针是vnode的一个元素，不能直接访问，需要用lseek函数来访问这个指针。
* 当我们打开一个文件时，文件指针默认指向文件流的开始，我们也可以通过lseek来移动文件指针的位置。
* 如果先对一个文件写入若干个字节的内容后立即去读取的话，是读取不到刚写入的内容的，因为此时文件指针已经被write移动到了该内容的后面。

#### 2.用lseek计算文件长度

#### 3.用lseek构建空洞文件

* 空洞文件就是这个文件中有一段是空的，而普通文件是不能有空的，因为我们write时文件指针是依次从前往后移动的。
* 打开一个文件后，用lseek往后移动一段距离，在write写入，就会构成一个空洞文件。
* 空洞文件对多线程操作文件是及其有用的，有时候需要创建一个很大的文件，如果从头开始构建的时间很长，就可以用多个线程来同时对文件进行写入构建。

### 七、多次打开同一文件与O_APPEND

#### 1.重复打开同一文件读取

* 一个进程中两次打开同一文件，然后分别读取，结果是fd1和fd2分别读，两个文件指针相互独立。
* 文件指针是包含在动态文件的文件管理表中的，可以看出Linux系统的进程中不同的fd对应着不同的独立的文件管理表。

#### 2. 重复打开同一文件写入

* 一个进程中两次打开同一文件，然后分别写入，结果是：两个文件指针相互独立。
* 若希望接续写而不是分别写，在open时加入O_APPEND就可以了，O_TRUNC | O_APPEND也可以生效。

#### 3.O_APPEND的实现原理和其原子操作性说明

* O_APPEND可以让write多做一件事，就是移动自己的文件指针的同时也移动别人的文件指针。
* O_APPEND对文件指针的影响是原子性的。
* 原子操作的含义：这个操作一旦开始就不会被打断，必须等待其操作结束其他代码才能运行。

### 八、文件共享的实现方式

#### 1.什么是文件共享

* 文件共享就是同一个文件（同一个inode、vnode）被多个独立的读写体去同时操作。
* 文件共享的意义：可以通过文件共享来实现多线程同时操作一个大文件，以减少文件的读写时间，提升效率。

#### 2.文件共享的三种情况

* 文件共享的核心是如何实现多个文件描述符指向同一个文件。
* 1.同一个进程多次使用（同时）open打开同一个文件；2.在不同的进程中分别使用（同时）open打开同一个文件；3.使用Linux提供的dup和dup2来复制文件描述符。
* 分析文件共享的核心在于：分别写/读还是接续写/读。

#### 3.再论文案件描述符

* 文件描述符本质上是一个数字，这个数字是进程表中的文件描述表（数组）的一个表项，通过该表项可查找得到文件管理表指针，进而可以访问这个文件对应的文件管理表。
* 操作系统规定：fd从0开始分配，内核会从文件描述表中挑选一个未经使用的最小fd返回。
* fd中的0、1、2已经被默认被系统用占用了，分别对应三个文件stdin、stdout、stderr。因此用户进程得到的最小文件描述符是3。
* printf函数默认输出到stdout上，fprintf可以指定输出到那个文件描述符上。

### 九、文件描述符的复制--dup和dup2

#### 1.使用dup进行文件描述的复制

#### 2.使用dup的缺陷

* 不能制定新的文件描述符数字，只能由系统自动分配。

#### 3.使用dup2进行文件描述的复制

* dup2支持指定新的文件描述符数字。
* 利用dup2复制的文件描述符更原来的描述符进行交叉读写时，结果为接续读写而不是分别读写。

#### 4.重定位命令 > 

### 十、fcntl系统调用介绍

#### 1.fcntl的原型和作用

* fcntl是一个多功能文件管理工具，接收2个参数加1个变参。第一个参数是所需要操作文件描述符。第二个参数是cmd，表示要进行哪些操作。第三个arg变参是用来配合cmd使用的。

#### 2.fcntl常见的cmd



### 十一、标准IO库介绍

#### 1.标准IO和文件IO的区别

* 标准IO是C库函数,文件IO是API
* C库函数由API封装而来，比API好用。
* C库函数具有可移植性而API不具备。
* 性能和易用性上，C库函数更好一些，文件IO不带缓存，标准IO带缓存，标准IO比文件IO性能更高。

#### 2.常见标准IO介绍

* fopen、fread、fwrite、fclose、fseek

#### 3.一个简单的标准IO读写实例

## 第二章 文件属性  

### 一、Linux中各种文件类型

### 二、常用文件属性获取

### 三、stat函数应用实例

### 四、文件权限管理

### 五、读取目录文件


## 第三章 获取系统信息

### 一、关于时间的概念

### 二、Linux系统中的时间

### 三、Linux中使用随机数

### 四、proc文件系统介绍


## 第四章 Linux进程全解
### 一、程序的开始和结束

#### 1.main函数由谁调用

* 编译链接时的引导代码：操作系统其实在执行main之前也需要执行一段引导程序，编译链接时由链接器将编译器中事先准备好的引导代码给链接进去，跟应用程序构成最终的可执行程序。

* 运行时的加载器：当我们执行一个程序时，加载器负责将代码加载到内存中去执行。

* 程序在编译链接时用连接器（连接引导代码），运行时用加载器（加载到内存）。

* argc和argv的传参的实现涉及到引导代码、加载器。

#### 2.程序如何结束

* 正常终止：return、exit、_exit。
* 非正常终止：自己或他人发送非正常信号终止进程。

#### 3.atexit注册进程终止处理函数

### 二、进程环境

#### 1.环境变量

* export命令可查看环境变量
* 进程环境表：每一个进程都有一份环境变量构成的表格，当前进程中可以直接使用这些环境变量。进程环境表其实就是一个字符串数组，用environ变量指向它。
* 程序中通过environ全局变量使用环境变量。
* 我们写的程序可以无条件使用环境变量，一旦使用到了环境变量，那么程序就和操作系统有关了。
* 获取指定环境变量函数：getenv()。

#### 2.进程运行的虚拟地址空间

* 操作系统中每个进程早独立的地址空间中运行。
* 每个进程的逻辑地址空间均为4GB（32位操作系统）,其中0~1G位OS占用，1~4为应用程序占用。
* 操作系统会完成虚拟地址到物理地址的映射。
* 意义：进程隔离；提供多进程同时运行的环境。

### 三、进程的正式引入

#### 1.什么是进程

* 进程就是程序的一次运行过程，他是一个动态过程而不是静态实物。
* 进程控制块（PCB）是内核中专门用来管理一个进程的数据结构。

#### 2.进程ID

* 进程ID用来唯一标识一个进程，便于管理，位于PCB中。

* 常用获取进程ID的函数：

  ```c
  getpid()//获取当前进程ID
  getppid()//获取当前进程的父进程ID
  getuid()//获取用户ID
  geteuid()//获取有效用户ID
  getgid()//获取组ID
  getefid()//获取有效组ID
  ```

  

#### 3.多进程调度原理

* 操作系统通过合理调节同时运行多个进程，宏观上看是并行，微观上是串行。
* 实际上现代操作系统的最小调度单元是线程而不是进程。

### 四、fork系统调用创建子进程

#### 1.为什么要创建子进程

* 每一次程序的运行都需要一个进程，需要创建多个进程实现宏观上的并行

#### 2.fork系统调用的内部原理

* 进程的分裂生长模式：如果操作系统需要一个新进程来运行一个程序，那么操作系统就会用一个现有的进程来复制生成一个新进程，老进程叫父进程，新进程叫子进程。

* fork系统调用一次会返回两次，使用fork后要用if判断返回值，返回值等于0的就是子进程，返回值大于0的就是父进程。

* fork的返回值在父进程中等于本次创建的子进程ID，在子进程中等于0。

  ``` c
  #include<sys/type.h>
  #include<unistd.h>
  
  int main()
  {
      pid_t p = -1;
      p = fork();//返回两次
      if(p == 0)
      {
          //子进程
      }
      if(p > 0)
      {
          //父进程
      }
      if(p < 0)
      {
          //出错
      }
  
      return 0;
  }
  ```

  

#### 3.关于子进程

* 子进程由父进程复制而来，由自己独立的PCB，被内核同等调度。

### 五、父子进程对文件的操作

#### 1.子进程继承父进程中打开的文件

* 测试上下文：父进程先打开一个文件得到fd，然后在创建子进程，之后在父子进程中各自用write向fd写入内容。结果为接续写，原因是父子进程之间的fd对应的文件指针是彼此关联的（类似O_APPEND）。
* 实际测试时有时候会只看到某一进程写入的内容，原因时是该进程开始之前，另一进程已经结束了，导致文件被强制关闭，该进程打开后又因为O_TRUNC将内容清空了。

#### 2.父子进程各自打开文件实现文件共享

* 测试上下文：父进程open打开1.txt然后写入，子进程open打开1.txt然后写入。结果为分别写，原因是父子进程分离后才各自打开文件，这时候两个PCB已经相互独立，文件表也独立了，因此两次读写是完全独立的。
* 若在上诉测试中open时加入O_APPEND则可以把父子进程的文件指针关联起来，实现接续写。

#### 3.总结

* 父子进程会有关联：父进程在没有fork之前自己做的事情对子进程有很大影响，但是父进程fork之后自己在if里面做的事情对子进程就没有影响了。本质是fork内部实际上已经复制了父进程的PCB生成了子进程的PCB，两个进程已经独立被OS调度运行。
* 我们创建子进程的目的就是要去独立运行其他程序，否则创建子进程没有意义。

### 六、进程的诞生和消亡

#### 1.进程的诞生

* 进程0和进程1：进程0是由内核构建的，进程1是由进程0fork创建来的。
* 其他进程：都是由fork或则vfork创建而来的

#### 2.进程的消亡

* 正常终止和异常终止：进程正常运行然后由自己主动结束和被其他程序被动结束。
* 进程运行时需要消耗系统资源（内存、IO），进程终止时里应完全释放这些资源，如果没有释放这些资源，就丢失了。
* Linux系统设计时规定：每一个进程退出时，操作系统将自动回收这个进程涉及到的所有资源（malloc、open）,但是只回收了内存和IO，并没有回收这个进程本身占用的内存（主要是task_struct和栈内存）
* 每一个进程都需要一个来帮他释放本身占用的内存的过程，这个进程就是他的父进程。

#### 3.僵尸进程

* 僵尸进程即子进程先于父进程结束，但是父进程暂时还没有帮其释放资源，此时子进程成为僵尸进程。但子进程出task_struct和栈内存外其他空间皆已被清理。
* 父进程可以使用wait和waitpid以显示的方式回收子进程剩余的资源并获取子进程退出状态。
* 若父进程不显示回收子进程，当父进程结束时一样会回收已消亡的子进程的剩余资源。

#### 4.孤儿进程

* 父进程先于子进程结束，此时子进程成为一个孤儿进程。
* Linux系统规定：所有的孤儿进程都成为一个特殊的进程（进程1，也就是init进程）的子进程。

### 七、父进程wait（系统调用）回收子进程

#### 1.wait工作原理

* 子进程结束时，系统向其父进程发送SIGCHILD信号，父进程被唤醒后去回收僵尸子进程资源。
* 父进程调用wait后就进入阻塞状态，直到进程资源回收完成。但若父进程没有任何子进程则wait返回错误。
* 父子进程之间是异步的，SIGCHILD信号机制就是为了解决异步的父子进程之间的通信问题。

#### 2.wait编程实战

* wait原型pid_t wait(int *wstatus),参数\*wstatus用来返回子进程结束时的状态，父进程得到wait后再结合一些宏定义就可以得到关于子进程结束时的一些信息。
* wait的返回值pid_t就是本次回收的子进程的PID。即父进程wait回收子进程后可以得到子进程的PID以及子进程结束时的状态。

### 八、waitpid系统调用介绍

#### 1.waitpid和wait差别

* 基本功能一样，都是用来回收子进程。
* wait可以回收指定PID的子进程，也可以选择阻塞式或非阻塞式两种模式。

#### 2.wait原型介绍

* pid_t waitpid(pid_t pid, int *wstatus, int options),返回的pid_t为回收的子进程的PID。
* 输入的pid_t为指定的要回收的子进程ID，若为-1则不指定PID。
* 输入的\*wstatus用于接收子进程状态，options则为阻塞或非阻塞选项，0表示默认的阻塞方式，WNOHANG则表示非阻塞式。

#### 3.代码实例

```c

```

#### 4.竞态初步映入

* 竞态即竞争状态，多进程环境下，多个进程同时抢占系统资源（内存、CPU、文件IO）。
* 竞争状态对OS来说是很危险的，如果没有处理好就会造成结果不稳定。
* 操作系统提供了一系列消灭竞态的机制，我们需要在合适的地方使用合适的方式来消灭竞态。

### 九、exec函数族

#### 1.为什么需要exec族函数

* fork系统调用是为了执行新的程序，但需要直接在子进程的if里写入新的程序代码，这样不够灵活，
* 使用exec族函数可以运行新的可执行程序，即把一个编译好的可执行程序直接加载运行。

### 十、进程状态和system函数

#### 1.进程的5种状态

* 就绪态
* 运行态
* 僵尸态
* 等待态
* 暂停态

#### 2.进程各种状态之间的转换

#### 3.system函数简介

* system函数 = fork + exec系列函数，其原型为int system(const char *string)。

* system函数是原子操作，即整个过程一旦开始就不能被打断（没有竞争状态），直到执行完毕。但若时间过长可能会影响操作系统整体的实时性。

* 使用system调用ls

  ```shell
  system("ls -al /etc/passwd/etc/shadow");
  ```

### 十一、进程关系

* 无关系
* 父子关系
* 进程组（group）:由若干个进程构成一个进程组，组内共享一些文件。
* 会话（session）：会话就是进程组的组。

### 十二、守护进程的引入

#### 1.进程查看命令ps

```shell
ps -ajx #偏向于显示与进程有关的各种ID号
ps -aux #偏向于显示进程占用的各种资源。
```

#### 2.向进程发送信号指令：kill

* kill-信号编号 进程ID：向特定进程发送一个特定信号。
* kill -9 XXX：向XXX这个进程发送9信号，即结束进程。

#### 3. 守护进程

* 守护进程：用daemon表示守护进程，简称为d，进程名后带d的进本上就是守护进程。
* 守护进程的特征：
  * 长期运行：一般都是开机运行到关机。
  * 与中控台脱离（终端被关闭）
  * 服务器一般都为守护进程：服务器程序就是一个一直运行的程序，可以为我们提供某种服务。

#### 4.常见守护进程

* syslogd:系统日志守护进程，提供syslog功能。
* cron：用来实现操作系统的时间管理，Linux中实现定时功能就需要用到cron。

### 十三、编写简单守护进程

### 十四、使用syslog来记录调试信息
### 十五、让程序单列运行
### 十六、Linux的进程间通信介绍
### 十七、管道
### 十八、SystemV IPC介绍


## 第五章、Linux中的信号

### 一、什么是信号

### 二、常见信号介绍

### 三、进程对信号的处理

### 四、alarm函数和pause函数


## 第六章、定时器与休眠

### 一、间隔式定时器

### 二、定时器的调度与精度

### 三、为阻塞操作设置超时

### 四、暂停运行（休眠）一段固定时间

### 五、POSIX时钟

### 六、POSIX间隔式定时器

### 七、利用文件描述符进行通知的定时器：timerfd API

## 第七章、Linux线程全解

### 一、再论进程
#### 1.多进程实现同实读取键盘和鼠标
* 创建子进程，在父子进程中分别进行读鼠标和键盘的工作

#### 2.使用进程的优势
* CPU分时复用,单核心CPU可以宏观上实现的多任务并行

#### 3.使用进程技术的劣势
* 进程间切换开销大进程间通信麻烦且效率低下

#### 4.解决方案----线程技术
* 线程技术保留进程实现多任务的特性线程的改进就是线程切间切换和通信上提升效率，继承线程的优点，克服线程的缺点多线程中多核心CPU更具优势，因为每个核心可以处理一个线程

### 二、线程的引入

#### 1.使用线程技术同时读取键盘和鼠标

#### 2. Linux中的线程简介

* 线程是一种轻量级进程
* 线程是参与内核调度的最小单元
* 一个进程中可以有多个线程

#### 3.线程技术的优势

* 像进程一样被OS调度
* 同一进程的多个线程之间很容易进行高效通信
* 在多核心CPU架构下效率最大化

#### 4.线程间通信方式

* 信号：用pthread_kill对线程发送信号，目标线程用sigaction来处理。
* 信号量：用于同步，一个线程阻塞等待另一个线程给他发信号量才会继续执行。
* 锁机制：互斥锁（用于保护共享数据或保持互斥操作）；条件变量（与信号量类似，与互斥锁一起使用）；自旋锁；读写锁；

### 三、线程常见函数

#### 1.线程的创建和回收

* pthread_create：主线程用来创建子线程
* pthread_join：主线程用来阻塞等待回收子线程
* pthread_detach：主线程用来分离线程，分离后主线程不必再去回收子线程

#### 2.线程取消

* pthread_cancel：线程调用该函数去取消（结束）子线程
* pthread_setcancelstate：子线程用来设置自己是否允许被取消
* pthread_setcanceltype：子线程用来设置自己取消类型（立即取消or等执行到cancellation point的函数时才会取消）

#### 3. 线程函数退出

* pthread_exit | return：都可以用于子线程退出，注意exit是用于进程退出的。
* pthread_cleanup_push和pthread_cleanup_pop：线程退出时需要调用的清理函数

#### 4.获取线程ID

* pthread_self

#### 5.发送信号

* pthraed_kill

### 四、线程同步之信号量



### 五、线程同步之互斥锁

### 六、线程同步之条件变量

#### 1.什么是条件变量

* 条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程阻塞等待条件成立而挂起，另一个线程使条件成立
* 为了防止竞争，条件变量的使用总是和互斥锁结合在一起。

#### 2.相关函数

* pthread_cond_init
* pthread_cond_destroy
* pthread_cond_wait
* pthread_cond_signal/pthread_cond_boardcast

## 第八章、Linux网络编程

### 一、Linux网络编程框架

#### 1.网络是分层的

* OSI七层模型：应用层、表示层、会话层、传输层、数据链路层、物理层
* 互联网极其复杂，需要分层以便更好地实现网络通信。

#### 2.TCP/IP协议的引入

* TCP/IP协议是用的最多的网络协议。
* TCP/IP协议分为4层，对迎着OSI的7层：应用层（应用层、表示层、会话层），传输层、网络层、数据链路层（链路层、物理层）
* 网络编程最应该关注应用层，了解传输层，网络层和链路层不用管。

#### 3.BS和CS

* BS架构：broswer-server。浏览器-服务器架构
* CS架构：client-server。客户端-服务器架构

### 二、TCP协议的学习

#### 1.关于TCP理解的重点

* TCP协议工作在传输层，对上服务socket接口，对下调用IP层。
* TCP协议面向连接，通信前必须三次握手建立连接关系。
* TCP协议提供可靠传输，不怕丢包、乱序问题

#### 2.TCP如何保证可靠传输

###  一、网络基本常识

#### 1.七层网络协议模型

* 应用层 - 主要用于将数据交给应用程序
* 表示层 - 主要用于按照统一的格式进行数据的封装
* 会话层 - 主要用于控制会话的建立、关闭等操作
* 传输层 - 主要用于数据的检查和重新排序等
* 网络层 - 主要用于选择具体的网络协议再次封装和发送
* 数据链路层 - 主要用从将数据转换为高低电平信号等
* 物理层 - 主要用于交换机等设备网络

#### 2.常见的网络协议

* tcp协议 - 传输控制协议，是一种面向连接的协议
* udp协议 - 用户数据报协议，是一种非面向连接的协议
* ip协议 - 互联网协议，是上述两种协议的底层协议

#### 3.IP地址和子网掩码

* IP地址 - 是互联网中的唯一标识，其本质上就是一个由32位二进制组成的整数，也有128位二进制组成的整数，日常生活中采用点分十进制表示法来描述IP地址，也就是将每一个字节的二进制转换为一个十进制的整数，不同的整数之间采用小数点分割。

* ```c
  A类：0 + 7位网络地址 + 24位主机地址
  B类：10 + 14位网络地址 + 16位主机地址
  C类：110 + 21位网络地址 +8位主机地址
  D类：1110 + 28位多播地址
  ```

#### 4.子网掩码

* 主要用于划分IP地址中的网络地址和主机地址，以及判断两个IP地址是否在同一个子网中，具体的划分方法为：IP地址 & 子网掩码 = 网络地址+ 主机地址

#### 5.端口号和字节序

* IP地址 - 定位到具体的某一台主机/设备
* 端口号 - 定位到主机上的具体某个进程
* 网络编程中需要提供：IP地址 + 端口号；端口号本质上是unsigned short类型，范围是0~65535，其中0~1024之间的端口被系统调用占用，因此编程从1025开始使用。

#### 5.字节序

* 小端系统：主要指将地位数据存放到地位内存地址的系统
* 大端系统：主要是指将低位数据存放在高位内存地址的系统
* 一般来说，对于所有发送到网络中的多字节整数来说，先转化为网络字节序在发送，而对于所有从网络中接收到的多字节整数来说，需要先转化为主机字节序在解析，二网络字节序本质上就是大端字节序
* htons 主机字节序转化为网络字节序


## 第九章、内存管理

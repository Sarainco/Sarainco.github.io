<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Sarainco</title><link>https://Sarainco.github.io</link><description>个人博客</description><copyright>Sarainco</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.com/Sarainco/yuji/blob/main/img_tool/logo.png?raw=true</url><title>avatar</title><link>https://Sarainco.github.io</link></image><lastBuildDate>Mon, 07 Oct 2024 13:13:00 +0000</lastBuildDate><managingEditor>Sarainco</managingEditor><ttl>60</ttl><webMaster>Sarainco</webMaster><item><title>嵌入式程序安全问题</title><link>https://Sarainco.github.io/post/qian-ru-shi-cheng-xu-an-quan-wen-ti.html</link><description>### 一、千奇百怪的BUG&#13;
&#13;
#### 1.数组越界&#13;
&#13;
```c&#13;
void buf_overflow(int n, char val)&#13;
{&#13;
    volatile char buf[5];//内存分配的时遵循地址对齐原则，分配8个字节&#13;
    volatile int a = 0x55;&#13;
    buf[0] = 0x5a;&#13;
    a++;&#13;
    buf[n] = val;&#13;
    printf('buf[0] =  0x%x a = 0x%x\n', buf[0], a);//buf[0] =  0x5a a = 0x56 || 段错误 (核心已转储)&#13;
}//函数返回地址也在栈空间&#13;
```&#13;
&#13;
* 变量被修改（不一定，分配内存存在内存对齐）&#13;
* 返回地址被修改，可能会执行到别的函数（返回值刚好是另一个函数的地址）  &#13;
* 远在天边的函数变量被修改&#13;
&#13;
#### 2.未赋值的函数指针&#13;
&#13;
```c&#13;
int (*f) (int a, int b)//定义函数指针 f = 0x00000000&#13;
```&#13;
&#13;
#### 3.加不加打印效果不一样&#13;
&#13;
* 一个直接用变量值，一个去栈里面拿值用&#13;
&#13;
#### 4.加上for循环就没问题了&#13;
&#13;
* 主要是因为定义了一个新的变量，在栈区&#13;
&#13;
### 二、栈溢出&#13;
&#13;
* 栈溢出是最常见、危害最大的软件漏洞之一；要理解栈溢出攻击的原理，需要对计算机程序中函数的调用和返回过程的底层细节有清晰的理解，尤其时这样的一个问题：计算机是如何保存某个函数调用的吓一跳指令地址，实现函数执行完成之后跳回函数调用处，继续往下执行的？&#13;
&#13;
#### 1.什么是栈溢出&#13;
&#13;
* 在这里存在漏洞的关键在于，函数返回后，继续执行的下一条指令地址是从内存的某一个位置读出来的，如果内存中的这个值在函数返回之前被修改，那么程序的执行流程就会被修改。</description><guid isPermaLink="true">https://Sarainco.github.io/post/qian-ru-shi-cheng-xu-an-quan-wen-ti.html</guid><pubDate>Mon, 07 Oct 2024 13:08:25 +0000</pubDate></item><item><title>Linux内核框架</title><link>https://Sarainco.github.io/post/Linux-nei-he-kuang-jia.html</link><description>#### Linux内核框架&#13;
![This is the frame photo](https://raw.githubusercontent.com/Sarainco/yuji/refs/heads/main/img_tool/Linux/Linux%E5%86%85%E6%A0%B8%E6%A1%86%E6%9E%B6.png)。</description><guid isPermaLink="true">https://Sarainco.github.io/post/Linux-nei-he-kuang-jia.html</guid><pubDate>Thu, 03 Oct 2024 06:11:06 +0000</pubDate></item><item><title>Linux系统编程</title><link>https://Sarainco.github.io/post/Linux-xi-tong-bian-cheng.html</link><description># 应用编程与网络编程&#13;
&#13;
## 第一章 Linux中的文件IO&#13;
&#13;
### 一、文件操作的主要API&#13;
&#13;
#### 1.文件操作的主要API&#13;
&#13;
* API是一些由Linux系统提供支持的函数，有应用程序来使用。</description><guid isPermaLink="true">https://Sarainco.github.io/post/Linux-xi-tong-bian-cheng.html</guid><pubDate>Tue, 01 Oct 2024 13:41:47 +0000</pubDate></item></channel></rss>